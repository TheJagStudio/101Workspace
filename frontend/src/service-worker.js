/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
	// Return false to exempt requests from being fulfilled by index.html.
	({ request, url }) => {
		// If this isn't a navigation, skip.
		if (request.mode !== "navigate") {
			return false;
		} // If this is a URL that starts with /_, skip.

		if (url.pathname.startsWith("/_")) {
			return false;
		} // If this looks like a URL for a resource, because it contains // a file extension, skip.

		if (url.pathname.match(fileExtensionRegexp)) {
			return false;
		} // Return true to signal that we want to use the handler.

		return true;
	},
	createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
	// Add in any other file extensions or routing criteria as needed.
	({ url }) => url.origin === self.location.origin && url.pathname.endsWith(".png"), // Customize this strategy as needed, e.g., by changing to CacheFirst.
	new StaleWhileRevalidate({
		cacheName: "images",
		plugins: [
			// Ensure that once this runtime cache reaches a maximum size the
			// least-recently used images are removed.
			new ExpirationPlugin({ maxEntries: 50 }),
		],
	})
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting();
	}
});

// Any other custom service worker logic can go here.
// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting();
	}
});

// --- Geolocation Background Sync ---

// IndexedDB Helper Functions
const getFromStore = (db, storeName, key) => {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(storeName, "readonly");
        const store = transaction.objectStore(storeName);
        const request = store.get(key);
        request.onerror = (event) => reject(event.target.error);
        request.onsuccess = (event) => resolve(event.target.result);
    });
};

const putInStore = (db, storeName, value) => {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(storeName, "readwrite");
        const store = transaction.objectStore(storeName);
        const request = store.put(value);
        request.onerror = (event) => reject(event.target.error);
        request.onsuccess = (event) => resolve(event.target.result);
    });
};

// Function to fetch settings from the server
const fetchTrackerSettings = async (config) => {
    try {
        const response = await fetch(`${new URL(self.registration.scope).origin}/api/tracker/admin/settings/`, {
            headers: {
                'Authorization': `Bearer ${config.accessToken}`,
                'Content-Type': 'application/json',
            },
        });
        if (!response.ok) throw new Error('Failed to fetch settings');
        return await response.json();
    } catch (error) {
        console.error('[Service Worker] Error fetching settings:', error);
        return null;
    }
};

// Main function to perform the location ping
const performLocationPing = async () => {
    console.log("[Service Worker] Executing background location ping.");

    const openRequest = indexedDB.open("tracker-db", 1);

    openRequest.onerror = () => console.error("[Service Worker] Error opening IndexedDB.");
    openRequest.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains("config")) {
            db.createObjectStore("config", { keyPath: "key" });
        }
        if (!db.objectStoreNames.contains("settings")) {
            db.createObjectStore("settings", { keyPath: "key" });
        }
    };

    openRequest.onsuccess = async (event) => {
        const db = event.target.result;
        try {
            const config = await getFromStore(db, "config", "trackerConfig");

            // Only run if a salesman has enabled tracking in the app
            if (!config || !config.isTracking || !config.isSalesman) {
                console.log("[Service Worker] Tracking is disabled. Skipping ping.");
                const registration = await self.registration;
                await registration.periodicSync.unregister("location-sync");
                return;
            }

            // Fetch and update settings periodically
            const settings = await getFromStore(db, "settings", "trackerSettings");
            const now = Date.now();
            if (!settings || !settings.lastUpdated || (now - settings.lastUpdated > 5 * 60 * 1000)) {
                const newSettings = await fetchTrackerSettings(config);
                if (newSettings) {
                    await putInStore(db, "settings", {
                        key: "trackerSettings",
                        ...newSettings,
                        lastUpdated: now
                    });
                }
            }

            // Get current position with a timeout
            const getPositionWithTimeout = () => {
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Geolocation timeout'));
                    }, 30000); // 30 second timeout

                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            clearTimeout(timeoutId);
                            resolve(position);
                        },
                        (error) => {
                            clearTimeout(timeoutId);
                            reject(error);
                        },
                        { 
                            enableHighAccuracy: true,
                            maximumAge: 0,
                            timeout: 30000
                        }
                    );
                });
            };

            try {
                const position = await getPositionWithTimeout();
                const { latitude, longitude } = position.coords;

                // Get Battery level
                let batteryLevel = 100;
                if ("getBattery" in navigator) {
                    const battery = await navigator.getBattery();
                    batteryLevel = Math.round(battery.level * 100);
                }

                // Send location update to server
                const response = await fetch(config.apiUrl, {
                    method: "POST",
                    headers: {
                        Authorization: `Bearer ${config.accessToken}`,
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ 
                        latitude, 
                        longitude, 
                        battery: batteryLevel,
                        timestamp: new Date().toISOString()
                    }),
                });

                if (!response.ok) {
                    throw new Error(`Server responded with status: ${response.status}`);
                }

                console.log("[Service Worker] Location ping sent successfully.");
            } catch (error) {
                console.error("[Service Worker] Error during location update:", error);
            }

        } catch (error) {
            console.error("[Service Worker] Failed to perform location ping:", error);
        } finally {
            db.close();
        }
    };
};

// Listen for the periodic sync event
self.addEventListener("periodicsync", (event) => {
    if (event.tag === "location-sync") {
        event.waitUntil(
            performLocationPing().catch(error => {
                console.error("[Service Worker] Periodic sync failed:", error);
            })
        );
    }
});

// Listen for messages from the main app
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'FORCE_LOCATION_UPDATE') {
        event.waitUntil(
            performLocationPing().catch(error => {
                console.error("[Service Worker] Forced location update failed:", error);
            })
        );
    }
});
